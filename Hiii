1. Написать рефлексивный toString(): 

public static String toString(Object o) 

Метод принимает любой объект и формирует строку на основании его полей без необходимости переопределять метод toString() объекта. 

Добавить аннотацию @Exclude для полей, которые не должны быть включены в результирующую строку. 

Методы, которые могут понадобиться: 
Object.getClass() 

Class.getDeclaredFields() 
Class.getSimpleName() 
Class.isPrimitive() 
Class.isArray() 

Field.getName() 
Field.getType() 
Field.setAccessible() 
Field.get() 

2. Написать простой Dependency Injection Framework. 

Всю логику можно заключить в классе DIContext, благодаря которому можно создавать экземпляр любого класса с автоматически установленными зависимостями. 

Например, есть классы в пакете reflection: 

interface I { 
String getValue(); 
} 

class Imlp implements I { 
String getValue() { 
return String.valueOf(Math.random()); 
} 
} 

class A { 
private String str; 

@ Resource (Impl.class) 
private I i; 
} 

class B { 
private int val; 

@ Resource 
private A aVal; 

public I getI() { 
return aVal.getI(); 
} 
} 

И следующий код создаст полноценный объект B, у которого все аннотированные поля будут инициализированы: 

public static void main(String[] args) { 
DIContext ctx = new DIContext(); 

B b = ctx.get("reflection.B"); // используйте generics, чтобы не делать cast 

String randomString = b.getI().getValue(); 
I i = ctx.get("reflection.Impl"); 
} 

Используйте свои исключения, которые будут выбрасываться в случае, если невозможно инициализировать объект.


Самостоятельно изучить паттерн Стратегия. Реализовать Logger.
1. Интерфейс ILogger с мотодом write()
2. Реализовать три стратегии:
ConsoleLogger - выводит сообщения в консоль
FileLogger - записывает сообщение в файл
TimeFileLogger - записывает сообщение в файл + текущее время
3. Реализовать классы, исползующие эти стратегии.
Запись в файл должна работать!

+время в message

Задачки:
1. Необходимо выполнить подсчет топ 100 слов параллельно. Количество потоков должно быть равно числу доступных процессоров в системе (Runtime.getRuntime().availableProcessors()). Каждый поток собирает свой результат (Map), а потом сливает в общий (Map). Первый поток, который создавал другие треды должен ожидать их завершения с помощью метода join() и выводить результат.

Не забывайте использовать синхронизацию при доступе к общим ресурсам.

Потокобезопасные коллекции не использовать! 

2. Пиццерия. Есть клиент (main), официант (waiter), повар (cooker). официант и повар спят, пока не появится клиент. Клиент составляет заказ и будит официанта, официант, относит заказ повару и будит его. Повар готовит и возвращает блюдо. Каждый из потоков после выполнения задачи засыпает.

а) Повар просто возвращает блюдо (пишет в консоль).
б) Повар будит клиента и отдает ему блюдо.
в) Повар будит официанта и передает ему блюдо, официант будит клиента и отдает заказ.
