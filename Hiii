1. Написать рефлексивный toString(): 

public static String toString(Object o) 

Метод принимает любой объект и формирует строку на основании его полей без необходимости переопределять метод toString() объекта. 

Добавить аннотацию @Exclude для полей, которые не должны быть включены в результирующую строку. 

Методы, которые могут понадобиться: 
Object.getClass() 

Class.getDeclaredFields() 
Class.getSimpleName() 
Class.isPrimitive() 
Class.isArray() 

Field.getName() 
Field.getType() 
Field.setAccessible() 
Field.get() 

2. Написать простой Dependency Injection Framework. 

Всю логику можно заключить в классе DIContext, благодаря которому можно создавать экземпляр любого класса с автоматически установленными зависимостями. 

Например, есть классы в пакете reflection: 

interface I { 
String getValue(); 
} 

class Imlp implements I { 
String getValue() { 
return String.valueOf(Math.random()); 
} 
} 

class A { 
private String str; 

@ Resource (Impl.class) 
private I i; 
} 

class B { 
private int val; 

@ Resource 
private A aVal; 

public I getI() { 
return aVal.getI(); 
} 
} 

И следующий код создаст полноценный объект B, у которого все аннотированные поля будут инициализированы: 

public static void main(String[] args) { 
DIContext ctx = new DIContext(); 

B b = ctx.get("reflection.B"); // используйте generics, чтобы не делать cast 

String randomString = b.getI().getValue(); 
I i = ctx.get("reflection.Impl"); 
} 

Используйте свои исключения, которые будут выбрасываться в случае, если невозможно инициализировать объект.


Самостоятельно изучить паттерн Стратегия. Реализовать Logger.
1. Интерфейс ILogger с мотодом write()
2. Реализовать три стратегии:
ConsoleLogger - выводит сообщения в консоль
FileLogger - записывает сообщение в файл
TimeFileLogger - записывает сообщение в файл + текущее время
3. Реализовать классы, исползующие эти стратегии.
Запись в файл должна работать!

+время в message