1. Написать рефлексивный toString(): 

public static String toString(Object o) 

Метод принимает любой объект и формирует строку на основании его полей без необходимости переопределять метод toString() объекта. 

Добавить аннотацию @Exclude для полей, которые не должны быть включены в результирующую строку. 

Методы, которые могут понадобиться: 
Object.getClass() 

Class.getDeclaredFields() 
Class.getSimpleName() 
Class.isPrimitive() 
Class.isArray() 

Field.getName() 
Field.getType() 
Field.setAccessible() 
Field.get() 

2. Написать простой Dependency Injection Framework. 

Всю логику можно заключить в классе DIContext, благодаря которому можно создавать экземпляр любого класса с автоматически установленными зависимостями. 

Например, есть классы в пакете reflection: 

interface I { 
String getValue(); 
} 

class Imlp implements I { 
String getValue() { 
return String.valueOf(Math.random()); 
} 
} 

class A { 
private String str; 

@ Resource (Impl.class) 
private I i; 
} 

class B { 
private int val; 

@ Resource 
private A aVal; 

public I getI() { 
return aVal.getI(); 
} 
} 

И следующий код создаст полноценный объект B, у которого все аннотированные поля будут инициализированы: 

public static void main(String[] args) { 
DIContext ctx = new DIContext(); 

B b = ctx.get("reflection.B"); // используйте generics, чтобы не делать cast 

String randomString = b.getI().getValue(); 
I i = ctx.get("reflection.Impl"); 
} 

Используйте свои исключения, которые будут выбрасываться в случае, если невозможно инициализировать объект.


Самостоятельно изучить паттерн Стратегия. Реализовать Logger.
1. Интерфейс ILogger с мотодом write()
2. Реализовать три стратегии:
ConsoleLogger - выводит сообщения в консоль
FileLogger - записывает сообщение в файл
TimeFileLogger - записывает сообщение в файл + текущее время
3. Реализовать классы, исползующие эти стратегии.
Запись в файл должна работать!

+время в message

Задачки:
1. Необходимо выполнить подсчет топ 100 слов параллельно. Количество потоков должно быть равно числу доступных процессоров в системе (Runtime.getRuntime().availableProcessors()). Каждый поток собирает свой результат (Map), а потом сливает в общий (Map). Первый поток, который создавал другие треды должен ожидать их завершения с помощью метода join() и выводить результат.

Не забывайте использовать синхронизацию при доступе к общим ресурсам.

Потокобезопасные коллекции не использовать! 

2. Пиццерия. Есть клиент (main), официант (waiter), повар (cooker). официант и повар спят, пока не появится клиент. Клиент составляет заказ и будит официанта, официант, относит заказ повару и будит его. Повар готовит и возвращает блюдо. Каждый из потоков после выполнения задачи засыпает.

а) Повар просто возвращает блюдо (пишет в консоль).
б) Повар будит клиента и отдает ему блюдо.
в) Повар будит официанта и передает ему блюдо, официант будит клиента и отдает заказ.

1. Используя блокирующие очереди сосчитать топ слов как из предыдущего задания. Вариантом решения может быть:
main создает потоки Worker, которые ждут строки из очереди на методе take(). Далее main читает с диска и добавляет строки в очереди, последними строками будут стоп-строки.

Worker'ы при получении стоп-строки добавляют свою внутреннюю мапу в следующую очередь и завершают свою работу.

main же ждет мапы со всех воркеров на второй очереди и результат собирает в результирующую мапу.

В итоге, не должно быть нигде явной синхронизации и использованы две блокирующие очереди

2. Точно так же сделать пиццерию на очередях: клиенты складывают заказы в очередь 1, официанты из нее заказы забирают и добавляют в очередь 2, из которой повар заказ забирает и готовит, после чего он готовые блюда складывает в очередь 3, из который клиенты будут забирать заказы. Сами же клиенты


Обязательно решить одну задачу (при решении использовать классы из пакета java.util.concurrent):
Задача 1
Библиотека. Доступны для чтения несколько книг. Одинаковых книг в библиотеке нет. Некоторые выдаются на руки, некоторые только в читальный зал. Читатель может брать на руки и в читальный зал несколько книг.
Задача 2
Порт. Корабли заходят в порт для разгрузки/загрузки. Работает несколько причалов. У одного причала может стоять один корабль. Корабль может загружаться у причала, разгружаться или выполнять оба действия.
